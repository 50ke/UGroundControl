// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: link_protocol.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_link_5fprotocol_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_link_5fprotocol_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "msg_enum.pb.h"
#include "msg_heartbeat.pb.h"
#include "msg_connect_request.pb.h"
#include "msg_connect_response.pb.h"
#include "msg_disconnect_request.pb.h"
#include "msg_disconnect_response.pb.h"
#include "msg_battery_status.pb.h"
#include "msg_command.pb.h"
#include "msg_mission_clear_request.pb.h"
#include "msg_mission_clear_response.pb.h"
#include "msg_mission_current.pb.h"
#include "msg_mission_download_request.pb.h"
#include "msg_mission_download_response.pb.h"
#include "msg_mission_item.pb.h"
#include "msg_mission_set_current.pb.h"
#include "msg_mission_upload_request.pb.h"
#include "msg_mission_upload_response.pb.h"
#include "msg_param_item.pb.h"
#include "msg_param_read_request.pb.h"
#include "msg_param_read_response.pb.h"
#include "msg_param_write_request.pb.h"
#include "msg_param_write_response.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_link_5fprotocol_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_link_5fprotocol_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_link_5fprotocol_2eproto;
namespace UsvLink {
class MessagePacket;
struct MessagePacketDefaultTypeInternal;
extern MessagePacketDefaultTypeInternal _MessagePacket_default_instance_;
}  // namespace UsvLink
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace UsvLink {

// ===================================================================


// -------------------------------------------------------------------

class MessagePacket final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UsvLink.MessagePacket) */ {
 public:
  inline MessagePacket() : MessagePacket(nullptr) {}
  ~MessagePacket() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MessagePacket(::google::protobuf::internal::ConstantInitialized);

  inline MessagePacket(const MessagePacket& from)
      : MessagePacket(nullptr, from) {}
  MessagePacket(MessagePacket&& from) noexcept
    : MessagePacket() {
    *this = ::std::move(from);
  }

  inline MessagePacket& operator=(const MessagePacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagePacket& operator=(MessagePacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessagePacket& default_instance() {
    return *internal_default_instance();
  }
  enum MsgPayloadCase {
    kHeartbeat = 9,
    kConnectRequest = 10,
    kConnectResponse = 11,
    kDisconnectRequest = 12,
    kDisconnectResponse = 13,
    kParamItem = 14,
    kParamReadRequest = 15,
    kParamReadResponse = 16,
    kParamWriteRequest = 17,
    kParamWriteResponse = 18,
    kMissionItem = 19,
    kMissionDownloadRequest = 20,
    kMissionDownloadResponse = 21,
    kMissionUploadRequest = 22,
    kMissionUploadResponse = 23,
    kMissionCurrent = 24,
    kMissionSetCurrent = 25,
    kMissionClearRequest = 26,
    kMissionClearResponse = 27,
    kBatteryStatus = 28,
    kCommand = 29,
    MSG_PAYLOAD_NOT_SET = 0,
  };

  static inline const MessagePacket* internal_default_instance() {
    return reinterpret_cast<const MessagePacket*>(
               &_MessagePacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MessagePacket& a, MessagePacket& b) {
    a.Swap(&b);
  }
  inline void Swap(MessagePacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagePacket* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessagePacket* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessagePacket>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessagePacket& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MessagePacket& from) {
    MessagePacket::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MessagePacket* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UsvLink.MessagePacket";
  }
  protected:
  explicit MessagePacket(::google::protobuf::Arena* arena);
  MessagePacket(::google::protobuf::Arena* arena, const MessagePacket& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSystemIdFieldNumber = 1,
    kComponentIdFieldNumber = 2,
    kTargetSystemIdFieldNumber = 3,
    kTargetComponentIdFieldNumber = 4,
    kTimeMsFieldNumber = 6,
    kMsgIdFieldNumber = 5,
    kMsgSrcFieldNumber = 7,
    kMsgLinkFieldNumber = 8,
    kHeartbeatFieldNumber = 9,
    kConnectRequestFieldNumber = 10,
    kConnectResponseFieldNumber = 11,
    kDisconnectRequestFieldNumber = 12,
    kDisconnectResponseFieldNumber = 13,
    kParamItemFieldNumber = 14,
    kParamReadRequestFieldNumber = 15,
    kParamReadResponseFieldNumber = 16,
    kParamWriteRequestFieldNumber = 17,
    kParamWriteResponseFieldNumber = 18,
    kMissionItemFieldNumber = 19,
    kMissionDownloadRequestFieldNumber = 20,
    kMissionDownloadResponseFieldNumber = 21,
    kMissionUploadRequestFieldNumber = 22,
    kMissionUploadResponseFieldNumber = 23,
    kMissionCurrentFieldNumber = 24,
    kMissionSetCurrentFieldNumber = 25,
    kMissionClearRequestFieldNumber = 26,
    kMissionClearResponseFieldNumber = 27,
    kBatteryStatusFieldNumber = 28,
    kCommandFieldNumber = 29,
  };
  // int32 system_id = 1;
  void clear_system_id() ;
  ::int32_t system_id() const;
  void set_system_id(::int32_t value);

  private:
  ::int32_t _internal_system_id() const;
  void _internal_set_system_id(::int32_t value);

  public:
  // optional int32 component_id = 2;
  bool has_component_id() const;
  void clear_component_id() ;
  ::int32_t component_id() const;
  void set_component_id(::int32_t value);

  private:
  ::int32_t _internal_component_id() const;
  void _internal_set_component_id(::int32_t value);

  public:
  // optional int32 target_system_id = 3;
  bool has_target_system_id() const;
  void clear_target_system_id() ;
  ::int32_t target_system_id() const;
  void set_target_system_id(::int32_t value);

  private:
  ::int32_t _internal_target_system_id() const;
  void _internal_set_target_system_id(::int32_t value);

  public:
  // optional int32 target_component_id = 4;
  bool has_target_component_id() const;
  void clear_target_component_id() ;
  ::int32_t target_component_id() const;
  void set_target_component_id(::int32_t value);

  private:
  ::int32_t _internal_target_component_id() const;
  void _internal_set_target_component_id(::int32_t value);

  public:
  // int64 time_ms = 6;
  void clear_time_ms() ;
  ::int64_t time_ms() const;
  void set_time_ms(::int64_t value);

  private:
  ::int64_t _internal_time_ms() const;
  void _internal_set_time_ms(::int64_t value);

  public:
  // .UsvLink.MsgId msg_id = 5;
  void clear_msg_id() ;
  ::UsvLink::MsgId msg_id() const;
  void set_msg_id(::UsvLink::MsgId value);

  private:
  ::UsvLink::MsgId _internal_msg_id() const;
  void _internal_set_msg_id(::UsvLink::MsgId value);

  public:
  // .UsvLink.MsgSrc msg_src = 7;
  void clear_msg_src() ;
  ::UsvLink::MsgSrc msg_src() const;
  void set_msg_src(::UsvLink::MsgSrc value);

  private:
  ::UsvLink::MsgSrc _internal_msg_src() const;
  void _internal_set_msg_src(::UsvLink::MsgSrc value);

  public:
  // .UsvLink.MsgLink msg_link = 8;
  void clear_msg_link() ;
  ::UsvLink::MsgLink msg_link() const;
  void set_msg_link(::UsvLink::MsgLink value);

  private:
  ::UsvLink::MsgLink _internal_msg_link() const;
  void _internal_set_msg_link(::UsvLink::MsgLink value);

  public:
  // .UsvLink.Heartbeat heartbeat = 9;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;

  public:
  void clear_heartbeat() ;
  const ::UsvLink::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::UsvLink::Heartbeat* release_heartbeat();
  ::UsvLink::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::UsvLink::Heartbeat* value);
  void unsafe_arena_set_allocated_heartbeat(::UsvLink::Heartbeat* value);
  ::UsvLink::Heartbeat* unsafe_arena_release_heartbeat();

  private:
  const ::UsvLink::Heartbeat& _internal_heartbeat() const;
  ::UsvLink::Heartbeat* _internal_mutable_heartbeat();

  public:
  // .UsvLink.ConnectRequest connect_request = 10;
  bool has_connect_request() const;
  private:
  bool _internal_has_connect_request() const;

  public:
  void clear_connect_request() ;
  const ::UsvLink::ConnectRequest& connect_request() const;
  PROTOBUF_NODISCARD ::UsvLink::ConnectRequest* release_connect_request();
  ::UsvLink::ConnectRequest* mutable_connect_request();
  void set_allocated_connect_request(::UsvLink::ConnectRequest* value);
  void unsafe_arena_set_allocated_connect_request(::UsvLink::ConnectRequest* value);
  ::UsvLink::ConnectRequest* unsafe_arena_release_connect_request();

  private:
  const ::UsvLink::ConnectRequest& _internal_connect_request() const;
  ::UsvLink::ConnectRequest* _internal_mutable_connect_request();

  public:
  // .UsvLink.ConnectResponse connect_response = 11;
  bool has_connect_response() const;
  private:
  bool _internal_has_connect_response() const;

  public:
  void clear_connect_response() ;
  const ::UsvLink::ConnectResponse& connect_response() const;
  PROTOBUF_NODISCARD ::UsvLink::ConnectResponse* release_connect_response();
  ::UsvLink::ConnectResponse* mutable_connect_response();
  void set_allocated_connect_response(::UsvLink::ConnectResponse* value);
  void unsafe_arena_set_allocated_connect_response(::UsvLink::ConnectResponse* value);
  ::UsvLink::ConnectResponse* unsafe_arena_release_connect_response();

  private:
  const ::UsvLink::ConnectResponse& _internal_connect_response() const;
  ::UsvLink::ConnectResponse* _internal_mutable_connect_response();

  public:
  // .UsvLink.DisconnectRequest disconnect_request = 12;
  bool has_disconnect_request() const;
  private:
  bool _internal_has_disconnect_request() const;

  public:
  void clear_disconnect_request() ;
  const ::UsvLink::DisconnectRequest& disconnect_request() const;
  PROTOBUF_NODISCARD ::UsvLink::DisconnectRequest* release_disconnect_request();
  ::UsvLink::DisconnectRequest* mutable_disconnect_request();
  void set_allocated_disconnect_request(::UsvLink::DisconnectRequest* value);
  void unsafe_arena_set_allocated_disconnect_request(::UsvLink::DisconnectRequest* value);
  ::UsvLink::DisconnectRequest* unsafe_arena_release_disconnect_request();

  private:
  const ::UsvLink::DisconnectRequest& _internal_disconnect_request() const;
  ::UsvLink::DisconnectRequest* _internal_mutable_disconnect_request();

  public:
  // .UsvLink.DisconnectResponse disconnect_response = 13;
  bool has_disconnect_response() const;
  private:
  bool _internal_has_disconnect_response() const;

  public:
  void clear_disconnect_response() ;
  const ::UsvLink::DisconnectResponse& disconnect_response() const;
  PROTOBUF_NODISCARD ::UsvLink::DisconnectResponse* release_disconnect_response();
  ::UsvLink::DisconnectResponse* mutable_disconnect_response();
  void set_allocated_disconnect_response(::UsvLink::DisconnectResponse* value);
  void unsafe_arena_set_allocated_disconnect_response(::UsvLink::DisconnectResponse* value);
  ::UsvLink::DisconnectResponse* unsafe_arena_release_disconnect_response();

  private:
  const ::UsvLink::DisconnectResponse& _internal_disconnect_response() const;
  ::UsvLink::DisconnectResponse* _internal_mutable_disconnect_response();

  public:
  // .UsvLink.ParamItem param_item = 14;
  bool has_param_item() const;
  private:
  bool _internal_has_param_item() const;

  public:
  void clear_param_item() ;
  const ::UsvLink::ParamItem& param_item() const;
  PROTOBUF_NODISCARD ::UsvLink::ParamItem* release_param_item();
  ::UsvLink::ParamItem* mutable_param_item();
  void set_allocated_param_item(::UsvLink::ParamItem* value);
  void unsafe_arena_set_allocated_param_item(::UsvLink::ParamItem* value);
  ::UsvLink::ParamItem* unsafe_arena_release_param_item();

  private:
  const ::UsvLink::ParamItem& _internal_param_item() const;
  ::UsvLink::ParamItem* _internal_mutable_param_item();

  public:
  // .UsvLink.ParamReadRequest param_read_request = 15;
  bool has_param_read_request() const;
  private:
  bool _internal_has_param_read_request() const;

  public:
  void clear_param_read_request() ;
  const ::UsvLink::ParamReadRequest& param_read_request() const;
  PROTOBUF_NODISCARD ::UsvLink::ParamReadRequest* release_param_read_request();
  ::UsvLink::ParamReadRequest* mutable_param_read_request();
  void set_allocated_param_read_request(::UsvLink::ParamReadRequest* value);
  void unsafe_arena_set_allocated_param_read_request(::UsvLink::ParamReadRequest* value);
  ::UsvLink::ParamReadRequest* unsafe_arena_release_param_read_request();

  private:
  const ::UsvLink::ParamReadRequest& _internal_param_read_request() const;
  ::UsvLink::ParamReadRequest* _internal_mutable_param_read_request();

  public:
  // .UsvLink.ParamReadResponse param_read_response = 16;
  bool has_param_read_response() const;
  private:
  bool _internal_has_param_read_response() const;

  public:
  void clear_param_read_response() ;
  const ::UsvLink::ParamReadResponse& param_read_response() const;
  PROTOBUF_NODISCARD ::UsvLink::ParamReadResponse* release_param_read_response();
  ::UsvLink::ParamReadResponse* mutable_param_read_response();
  void set_allocated_param_read_response(::UsvLink::ParamReadResponse* value);
  void unsafe_arena_set_allocated_param_read_response(::UsvLink::ParamReadResponse* value);
  ::UsvLink::ParamReadResponse* unsafe_arena_release_param_read_response();

  private:
  const ::UsvLink::ParamReadResponse& _internal_param_read_response() const;
  ::UsvLink::ParamReadResponse* _internal_mutable_param_read_response();

  public:
  // .UsvLink.ParamWriteRequest param_write_request = 17;
  bool has_param_write_request() const;
  private:
  bool _internal_has_param_write_request() const;

  public:
  void clear_param_write_request() ;
  const ::UsvLink::ParamWriteRequest& param_write_request() const;
  PROTOBUF_NODISCARD ::UsvLink::ParamWriteRequest* release_param_write_request();
  ::UsvLink::ParamWriteRequest* mutable_param_write_request();
  void set_allocated_param_write_request(::UsvLink::ParamWriteRequest* value);
  void unsafe_arena_set_allocated_param_write_request(::UsvLink::ParamWriteRequest* value);
  ::UsvLink::ParamWriteRequest* unsafe_arena_release_param_write_request();

  private:
  const ::UsvLink::ParamWriteRequest& _internal_param_write_request() const;
  ::UsvLink::ParamWriteRequest* _internal_mutable_param_write_request();

  public:
  // .UsvLink.ParamWriteResponse param_write_response = 18;
  bool has_param_write_response() const;
  private:
  bool _internal_has_param_write_response() const;

  public:
  void clear_param_write_response() ;
  const ::UsvLink::ParamWriteResponse& param_write_response() const;
  PROTOBUF_NODISCARD ::UsvLink::ParamWriteResponse* release_param_write_response();
  ::UsvLink::ParamWriteResponse* mutable_param_write_response();
  void set_allocated_param_write_response(::UsvLink::ParamWriteResponse* value);
  void unsafe_arena_set_allocated_param_write_response(::UsvLink::ParamWriteResponse* value);
  ::UsvLink::ParamWriteResponse* unsafe_arena_release_param_write_response();

  private:
  const ::UsvLink::ParamWriteResponse& _internal_param_write_response() const;
  ::UsvLink::ParamWriteResponse* _internal_mutable_param_write_response();

  public:
  // .UsvLink.MissionItem mission_item = 19;
  bool has_mission_item() const;
  private:
  bool _internal_has_mission_item() const;

  public:
  void clear_mission_item() ;
  const ::UsvLink::MissionItem& mission_item() const;
  PROTOBUF_NODISCARD ::UsvLink::MissionItem* release_mission_item();
  ::UsvLink::MissionItem* mutable_mission_item();
  void set_allocated_mission_item(::UsvLink::MissionItem* value);
  void unsafe_arena_set_allocated_mission_item(::UsvLink::MissionItem* value);
  ::UsvLink::MissionItem* unsafe_arena_release_mission_item();

  private:
  const ::UsvLink::MissionItem& _internal_mission_item() const;
  ::UsvLink::MissionItem* _internal_mutable_mission_item();

  public:
  // .UsvLink.MissionDownloadRequest mission_download_request = 20;
  bool has_mission_download_request() const;
  private:
  bool _internal_has_mission_download_request() const;

  public:
  void clear_mission_download_request() ;
  const ::UsvLink::MissionDownloadRequest& mission_download_request() const;
  PROTOBUF_NODISCARD ::UsvLink::MissionDownloadRequest* release_mission_download_request();
  ::UsvLink::MissionDownloadRequest* mutable_mission_download_request();
  void set_allocated_mission_download_request(::UsvLink::MissionDownloadRequest* value);
  void unsafe_arena_set_allocated_mission_download_request(::UsvLink::MissionDownloadRequest* value);
  ::UsvLink::MissionDownloadRequest* unsafe_arena_release_mission_download_request();

  private:
  const ::UsvLink::MissionDownloadRequest& _internal_mission_download_request() const;
  ::UsvLink::MissionDownloadRequest* _internal_mutable_mission_download_request();

  public:
  // .UsvLink.MissionDownloadResponse mission_download_response = 21;
  bool has_mission_download_response() const;
  private:
  bool _internal_has_mission_download_response() const;

  public:
  void clear_mission_download_response() ;
  const ::UsvLink::MissionDownloadResponse& mission_download_response() const;
  PROTOBUF_NODISCARD ::UsvLink::MissionDownloadResponse* release_mission_download_response();
  ::UsvLink::MissionDownloadResponse* mutable_mission_download_response();
  void set_allocated_mission_download_response(::UsvLink::MissionDownloadResponse* value);
  void unsafe_arena_set_allocated_mission_download_response(::UsvLink::MissionDownloadResponse* value);
  ::UsvLink::MissionDownloadResponse* unsafe_arena_release_mission_download_response();

  private:
  const ::UsvLink::MissionDownloadResponse& _internal_mission_download_response() const;
  ::UsvLink::MissionDownloadResponse* _internal_mutable_mission_download_response();

  public:
  // .UsvLink.MissionUploadRequest mission_upload_request = 22;
  bool has_mission_upload_request() const;
  private:
  bool _internal_has_mission_upload_request() const;

  public:
  void clear_mission_upload_request() ;
  const ::UsvLink::MissionUploadRequest& mission_upload_request() const;
  PROTOBUF_NODISCARD ::UsvLink::MissionUploadRequest* release_mission_upload_request();
  ::UsvLink::MissionUploadRequest* mutable_mission_upload_request();
  void set_allocated_mission_upload_request(::UsvLink::MissionUploadRequest* value);
  void unsafe_arena_set_allocated_mission_upload_request(::UsvLink::MissionUploadRequest* value);
  ::UsvLink::MissionUploadRequest* unsafe_arena_release_mission_upload_request();

  private:
  const ::UsvLink::MissionUploadRequest& _internal_mission_upload_request() const;
  ::UsvLink::MissionUploadRequest* _internal_mutable_mission_upload_request();

  public:
  // .UsvLink.MissionUploadResponse mission_upload_response = 23;
  bool has_mission_upload_response() const;
  private:
  bool _internal_has_mission_upload_response() const;

  public:
  void clear_mission_upload_response() ;
  const ::UsvLink::MissionUploadResponse& mission_upload_response() const;
  PROTOBUF_NODISCARD ::UsvLink::MissionUploadResponse* release_mission_upload_response();
  ::UsvLink::MissionUploadResponse* mutable_mission_upload_response();
  void set_allocated_mission_upload_response(::UsvLink::MissionUploadResponse* value);
  void unsafe_arena_set_allocated_mission_upload_response(::UsvLink::MissionUploadResponse* value);
  ::UsvLink::MissionUploadResponse* unsafe_arena_release_mission_upload_response();

  private:
  const ::UsvLink::MissionUploadResponse& _internal_mission_upload_response() const;
  ::UsvLink::MissionUploadResponse* _internal_mutable_mission_upload_response();

  public:
  // .UsvLink.MissionCurrent mission_current = 24;
  bool has_mission_current() const;
  private:
  bool _internal_has_mission_current() const;

  public:
  void clear_mission_current() ;
  const ::UsvLink::MissionCurrent& mission_current() const;
  PROTOBUF_NODISCARD ::UsvLink::MissionCurrent* release_mission_current();
  ::UsvLink::MissionCurrent* mutable_mission_current();
  void set_allocated_mission_current(::UsvLink::MissionCurrent* value);
  void unsafe_arena_set_allocated_mission_current(::UsvLink::MissionCurrent* value);
  ::UsvLink::MissionCurrent* unsafe_arena_release_mission_current();

  private:
  const ::UsvLink::MissionCurrent& _internal_mission_current() const;
  ::UsvLink::MissionCurrent* _internal_mutable_mission_current();

  public:
  // .UsvLink.MissionSetCurrent mission_set_current = 25;
  bool has_mission_set_current() const;
  private:
  bool _internal_has_mission_set_current() const;

  public:
  void clear_mission_set_current() ;
  const ::UsvLink::MissionSetCurrent& mission_set_current() const;
  PROTOBUF_NODISCARD ::UsvLink::MissionSetCurrent* release_mission_set_current();
  ::UsvLink::MissionSetCurrent* mutable_mission_set_current();
  void set_allocated_mission_set_current(::UsvLink::MissionSetCurrent* value);
  void unsafe_arena_set_allocated_mission_set_current(::UsvLink::MissionSetCurrent* value);
  ::UsvLink::MissionSetCurrent* unsafe_arena_release_mission_set_current();

  private:
  const ::UsvLink::MissionSetCurrent& _internal_mission_set_current() const;
  ::UsvLink::MissionSetCurrent* _internal_mutable_mission_set_current();

  public:
  // .UsvLink.MissionClearRequest mission_clear_request = 26;
  bool has_mission_clear_request() const;
  private:
  bool _internal_has_mission_clear_request() const;

  public:
  void clear_mission_clear_request() ;
  const ::UsvLink::MissionClearRequest& mission_clear_request() const;
  PROTOBUF_NODISCARD ::UsvLink::MissionClearRequest* release_mission_clear_request();
  ::UsvLink::MissionClearRequest* mutable_mission_clear_request();
  void set_allocated_mission_clear_request(::UsvLink::MissionClearRequest* value);
  void unsafe_arena_set_allocated_mission_clear_request(::UsvLink::MissionClearRequest* value);
  ::UsvLink::MissionClearRequest* unsafe_arena_release_mission_clear_request();

  private:
  const ::UsvLink::MissionClearRequest& _internal_mission_clear_request() const;
  ::UsvLink::MissionClearRequest* _internal_mutable_mission_clear_request();

  public:
  // .UsvLink.MissionClearResponse mission_clear_response = 27;
  bool has_mission_clear_response() const;
  private:
  bool _internal_has_mission_clear_response() const;

  public:
  void clear_mission_clear_response() ;
  const ::UsvLink::MissionClearResponse& mission_clear_response() const;
  PROTOBUF_NODISCARD ::UsvLink::MissionClearResponse* release_mission_clear_response();
  ::UsvLink::MissionClearResponse* mutable_mission_clear_response();
  void set_allocated_mission_clear_response(::UsvLink::MissionClearResponse* value);
  void unsafe_arena_set_allocated_mission_clear_response(::UsvLink::MissionClearResponse* value);
  ::UsvLink::MissionClearResponse* unsafe_arena_release_mission_clear_response();

  private:
  const ::UsvLink::MissionClearResponse& _internal_mission_clear_response() const;
  ::UsvLink::MissionClearResponse* _internal_mutable_mission_clear_response();

  public:
  // .UsvLink.BatteryStatus battery_status = 28;
  bool has_battery_status() const;
  private:
  bool _internal_has_battery_status() const;

  public:
  void clear_battery_status() ;
  const ::UsvLink::BatteryStatus& battery_status() const;
  PROTOBUF_NODISCARD ::UsvLink::BatteryStatus* release_battery_status();
  ::UsvLink::BatteryStatus* mutable_battery_status();
  void set_allocated_battery_status(::UsvLink::BatteryStatus* value);
  void unsafe_arena_set_allocated_battery_status(::UsvLink::BatteryStatus* value);
  ::UsvLink::BatteryStatus* unsafe_arena_release_battery_status();

  private:
  const ::UsvLink::BatteryStatus& _internal_battery_status() const;
  ::UsvLink::BatteryStatus* _internal_mutable_battery_status();

  public:
  // .UsvLink.Command command = 29;
  bool has_command() const;
  private:
  bool _internal_has_command() const;

  public:
  void clear_command() ;
  const ::UsvLink::Command& command() const;
  PROTOBUF_NODISCARD ::UsvLink::Command* release_command();
  ::UsvLink::Command* mutable_command();
  void set_allocated_command(::UsvLink::Command* value);
  void unsafe_arena_set_allocated_command(::UsvLink::Command* value);
  ::UsvLink::Command* unsafe_arena_release_command();

  private:
  const ::UsvLink::Command& _internal_command() const;
  ::UsvLink::Command* _internal_mutable_command();

  public:
  void clear_msg_payload();
  MsgPayloadCase msg_payload_case() const;
  // @@protoc_insertion_point(class_scope:UsvLink.MessagePacket)
 private:
  class _Internal;
  void set_has_heartbeat();
  void set_has_connect_request();
  void set_has_connect_response();
  void set_has_disconnect_request();
  void set_has_disconnect_response();
  void set_has_param_item();
  void set_has_param_read_request();
  void set_has_param_read_response();
  void set_has_param_write_request();
  void set_has_param_write_response();
  void set_has_mission_item();
  void set_has_mission_download_request();
  void set_has_mission_download_response();
  void set_has_mission_upload_request();
  void set_has_mission_upload_response();
  void set_has_mission_current();
  void set_has_mission_set_current();
  void set_has_mission_clear_request();
  void set_has_mission_clear_response();
  void set_has_battery_status();
  void set_has_command();

  inline bool has_msg_payload() const;
  inline void clear_has_msg_payload();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 29, 21,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t system_id_;
    ::int32_t component_id_;
    ::int32_t target_system_id_;
    ::int32_t target_component_id_;
    ::int64_t time_ms_;
    int msg_id_;
    int msg_src_;
    int msg_link_;
    union MsgPayloadUnion {
      constexpr MsgPayloadUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::UsvLink::Heartbeat* heartbeat_;
      ::UsvLink::ConnectRequest* connect_request_;
      ::UsvLink::ConnectResponse* connect_response_;
      ::UsvLink::DisconnectRequest* disconnect_request_;
      ::UsvLink::DisconnectResponse* disconnect_response_;
      ::UsvLink::ParamItem* param_item_;
      ::UsvLink::ParamReadRequest* param_read_request_;
      ::UsvLink::ParamReadResponse* param_read_response_;
      ::UsvLink::ParamWriteRequest* param_write_request_;
      ::UsvLink::ParamWriteResponse* param_write_response_;
      ::UsvLink::MissionItem* mission_item_;
      ::UsvLink::MissionDownloadRequest* mission_download_request_;
      ::UsvLink::MissionDownloadResponse* mission_download_response_;
      ::UsvLink::MissionUploadRequest* mission_upload_request_;
      ::UsvLink::MissionUploadResponse* mission_upload_response_;
      ::UsvLink::MissionCurrent* mission_current_;
      ::UsvLink::MissionSetCurrent* mission_set_current_;
      ::UsvLink::MissionClearRequest* mission_clear_request_;
      ::UsvLink::MissionClearResponse* mission_clear_response_;
      ::UsvLink::BatteryStatus* battery_status_;
      ::UsvLink::Command* command_;
    } msg_payload_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_link_5fprotocol_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MessagePacket

// int32 system_id = 1;
inline void MessagePacket::clear_system_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.system_id_ = 0;
}
inline ::int32_t MessagePacket::system_id() const {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.system_id)
  return _internal_system_id();
}
inline void MessagePacket::set_system_id(::int32_t value) {
  _internal_set_system_id(value);
  // @@protoc_insertion_point(field_set:UsvLink.MessagePacket.system_id)
}
inline ::int32_t MessagePacket::_internal_system_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.system_id_;
}
inline void MessagePacket::_internal_set_system_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.system_id_ = value;
}

// optional int32 component_id = 2;
inline bool MessagePacket::has_component_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MessagePacket::clear_component_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.component_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MessagePacket::component_id() const {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.component_id)
  return _internal_component_id();
}
inline void MessagePacket::set_component_id(::int32_t value) {
  _internal_set_component_id(value);
  // @@protoc_insertion_point(field_set:UsvLink.MessagePacket.component_id)
}
inline ::int32_t MessagePacket::_internal_component_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.component_id_;
}
inline void MessagePacket::_internal_set_component_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.component_id_ = value;
}

// optional int32 target_system_id = 3;
inline bool MessagePacket::has_target_system_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MessagePacket::clear_target_system_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_system_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MessagePacket::target_system_id() const {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.target_system_id)
  return _internal_target_system_id();
}
inline void MessagePacket::set_target_system_id(::int32_t value) {
  _internal_set_target_system_id(value);
  // @@protoc_insertion_point(field_set:UsvLink.MessagePacket.target_system_id)
}
inline ::int32_t MessagePacket::_internal_target_system_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_system_id_;
}
inline void MessagePacket::_internal_set_target_system_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.target_system_id_ = value;
}

// optional int32 target_component_id = 4;
inline bool MessagePacket::has_target_component_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MessagePacket::clear_target_component_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_component_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t MessagePacket::target_component_id() const {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.target_component_id)
  return _internal_target_component_id();
}
inline void MessagePacket::set_target_component_id(::int32_t value) {
  _internal_set_target_component_id(value);
  // @@protoc_insertion_point(field_set:UsvLink.MessagePacket.target_component_id)
}
inline ::int32_t MessagePacket::_internal_target_component_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_component_id_;
}
inline void MessagePacket::_internal_set_target_component_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.target_component_id_ = value;
}

// .UsvLink.MsgId msg_id = 5;
inline void MessagePacket::clear_msg_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_id_ = 0;
}
inline ::UsvLink::MsgId MessagePacket::msg_id() const {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.msg_id)
  return _internal_msg_id();
}
inline void MessagePacket::set_msg_id(::UsvLink::MsgId value) {
  _internal_set_msg_id(value);
  // @@protoc_insertion_point(field_set:UsvLink.MessagePacket.msg_id)
}
inline ::UsvLink::MsgId MessagePacket::_internal_msg_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::UsvLink::MsgId>(_impl_.msg_id_);
}
inline void MessagePacket::_internal_set_msg_id(::UsvLink::MsgId value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_id_ = value;
}

// int64 time_ms = 6;
inline void MessagePacket::clear_time_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ms_ = ::int64_t{0};
}
inline ::int64_t MessagePacket::time_ms() const {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.time_ms)
  return _internal_time_ms();
}
inline void MessagePacket::set_time_ms(::int64_t value) {
  _internal_set_time_ms(value);
  // @@protoc_insertion_point(field_set:UsvLink.MessagePacket.time_ms)
}
inline ::int64_t MessagePacket::_internal_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_ms_;
}
inline void MessagePacket::_internal_set_time_ms(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.time_ms_ = value;
}

// .UsvLink.MsgSrc msg_src = 7;
inline void MessagePacket::clear_msg_src() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_src_ = 0;
}
inline ::UsvLink::MsgSrc MessagePacket::msg_src() const {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.msg_src)
  return _internal_msg_src();
}
inline void MessagePacket::set_msg_src(::UsvLink::MsgSrc value) {
  _internal_set_msg_src(value);
  // @@protoc_insertion_point(field_set:UsvLink.MessagePacket.msg_src)
}
inline ::UsvLink::MsgSrc MessagePacket::_internal_msg_src() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::UsvLink::MsgSrc>(_impl_.msg_src_);
}
inline void MessagePacket::_internal_set_msg_src(::UsvLink::MsgSrc value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_src_ = value;
}

// .UsvLink.MsgLink msg_link = 8;
inline void MessagePacket::clear_msg_link() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msg_link_ = 0;
}
inline ::UsvLink::MsgLink MessagePacket::msg_link() const {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.msg_link)
  return _internal_msg_link();
}
inline void MessagePacket::set_msg_link(::UsvLink::MsgLink value) {
  _internal_set_msg_link(value);
  // @@protoc_insertion_point(field_set:UsvLink.MessagePacket.msg_link)
}
inline ::UsvLink::MsgLink MessagePacket::_internal_msg_link() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::UsvLink::MsgLink>(_impl_.msg_link_);
}
inline void MessagePacket::_internal_set_msg_link(::UsvLink::MsgLink value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.msg_link_ = value;
}

// .UsvLink.Heartbeat heartbeat = 9;
inline bool MessagePacket::has_heartbeat() const {
  return msg_payload_case() == kHeartbeat;
}
inline bool MessagePacket::_internal_has_heartbeat() const {
  return msg_payload_case() == kHeartbeat;
}
inline void MessagePacket::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline ::UsvLink::Heartbeat* MessagePacket::release_heartbeat() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.heartbeat)
  if (msg_payload_case() == kHeartbeat) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.heartbeat_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::Heartbeat& MessagePacket::_internal_heartbeat() const {
  return msg_payload_case() == kHeartbeat ? *_impl_.msg_payload_.heartbeat_ : reinterpret_cast<::UsvLink::Heartbeat&>(::UsvLink::_Heartbeat_default_instance_);
}
inline const ::UsvLink::Heartbeat& MessagePacket::heartbeat() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.heartbeat)
  return _internal_heartbeat();
}
inline ::UsvLink::Heartbeat* MessagePacket::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.heartbeat)
  if (msg_payload_case() == kHeartbeat) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.heartbeat_;
    _impl_.msg_payload_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_heartbeat(::UsvLink::Heartbeat* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_heartbeat();
    _impl_.msg_payload_.heartbeat_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.heartbeat)
}
inline ::UsvLink::Heartbeat* MessagePacket::_internal_mutable_heartbeat() {
  if (msg_payload_case() != kHeartbeat) {
    clear_msg_payload();
    set_has_heartbeat();
    _impl_.msg_payload_.heartbeat_ = CreateMaybeMessage<::UsvLink::Heartbeat>(GetArena());
  }
  return _impl_.msg_payload_.heartbeat_;
}
inline ::UsvLink::Heartbeat* MessagePacket::mutable_heartbeat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.heartbeat)
  return _msg;
}

// .UsvLink.ConnectRequest connect_request = 10;
inline bool MessagePacket::has_connect_request() const {
  return msg_payload_case() == kConnectRequest;
}
inline bool MessagePacket::_internal_has_connect_request() const {
  return msg_payload_case() == kConnectRequest;
}
inline void MessagePacket::set_has_connect_request() {
  _impl_._oneof_case_[0] = kConnectRequest;
}
inline ::UsvLink::ConnectRequest* MessagePacket::release_connect_request() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.connect_request)
  if (msg_payload_case() == kConnectRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.connect_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.connect_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::ConnectRequest& MessagePacket::_internal_connect_request() const {
  return msg_payload_case() == kConnectRequest ? *_impl_.msg_payload_.connect_request_ : reinterpret_cast<::UsvLink::ConnectRequest&>(::UsvLink::_ConnectRequest_default_instance_);
}
inline const ::UsvLink::ConnectRequest& MessagePacket::connect_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.connect_request)
  return _internal_connect_request();
}
inline ::UsvLink::ConnectRequest* MessagePacket::unsafe_arena_release_connect_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.connect_request)
  if (msg_payload_case() == kConnectRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.connect_request_;
    _impl_.msg_payload_.connect_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_connect_request(::UsvLink::ConnectRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_connect_request();
    _impl_.msg_payload_.connect_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.connect_request)
}
inline ::UsvLink::ConnectRequest* MessagePacket::_internal_mutable_connect_request() {
  if (msg_payload_case() != kConnectRequest) {
    clear_msg_payload();
    set_has_connect_request();
    _impl_.msg_payload_.connect_request_ = CreateMaybeMessage<::UsvLink::ConnectRequest>(GetArena());
  }
  return _impl_.msg_payload_.connect_request_;
}
inline ::UsvLink::ConnectRequest* MessagePacket::mutable_connect_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::ConnectRequest* _msg = _internal_mutable_connect_request();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.connect_request)
  return _msg;
}

// .UsvLink.ConnectResponse connect_response = 11;
inline bool MessagePacket::has_connect_response() const {
  return msg_payload_case() == kConnectResponse;
}
inline bool MessagePacket::_internal_has_connect_response() const {
  return msg_payload_case() == kConnectResponse;
}
inline void MessagePacket::set_has_connect_response() {
  _impl_._oneof_case_[0] = kConnectResponse;
}
inline ::UsvLink::ConnectResponse* MessagePacket::release_connect_response() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.connect_response)
  if (msg_payload_case() == kConnectResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.connect_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.connect_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::ConnectResponse& MessagePacket::_internal_connect_response() const {
  return msg_payload_case() == kConnectResponse ? *_impl_.msg_payload_.connect_response_ : reinterpret_cast<::UsvLink::ConnectResponse&>(::UsvLink::_ConnectResponse_default_instance_);
}
inline const ::UsvLink::ConnectResponse& MessagePacket::connect_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.connect_response)
  return _internal_connect_response();
}
inline ::UsvLink::ConnectResponse* MessagePacket::unsafe_arena_release_connect_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.connect_response)
  if (msg_payload_case() == kConnectResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.connect_response_;
    _impl_.msg_payload_.connect_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_connect_response(::UsvLink::ConnectResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_connect_response();
    _impl_.msg_payload_.connect_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.connect_response)
}
inline ::UsvLink::ConnectResponse* MessagePacket::_internal_mutable_connect_response() {
  if (msg_payload_case() != kConnectResponse) {
    clear_msg_payload();
    set_has_connect_response();
    _impl_.msg_payload_.connect_response_ = CreateMaybeMessage<::UsvLink::ConnectResponse>(GetArena());
  }
  return _impl_.msg_payload_.connect_response_;
}
inline ::UsvLink::ConnectResponse* MessagePacket::mutable_connect_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::ConnectResponse* _msg = _internal_mutable_connect_response();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.connect_response)
  return _msg;
}

// .UsvLink.DisconnectRequest disconnect_request = 12;
inline bool MessagePacket::has_disconnect_request() const {
  return msg_payload_case() == kDisconnectRequest;
}
inline bool MessagePacket::_internal_has_disconnect_request() const {
  return msg_payload_case() == kDisconnectRequest;
}
inline void MessagePacket::set_has_disconnect_request() {
  _impl_._oneof_case_[0] = kDisconnectRequest;
}
inline ::UsvLink::DisconnectRequest* MessagePacket::release_disconnect_request() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.disconnect_request)
  if (msg_payload_case() == kDisconnectRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.disconnect_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.disconnect_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::DisconnectRequest& MessagePacket::_internal_disconnect_request() const {
  return msg_payload_case() == kDisconnectRequest ? *_impl_.msg_payload_.disconnect_request_ : reinterpret_cast<::UsvLink::DisconnectRequest&>(::UsvLink::_DisconnectRequest_default_instance_);
}
inline const ::UsvLink::DisconnectRequest& MessagePacket::disconnect_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.disconnect_request)
  return _internal_disconnect_request();
}
inline ::UsvLink::DisconnectRequest* MessagePacket::unsafe_arena_release_disconnect_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.disconnect_request)
  if (msg_payload_case() == kDisconnectRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.disconnect_request_;
    _impl_.msg_payload_.disconnect_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_disconnect_request(::UsvLink::DisconnectRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_disconnect_request();
    _impl_.msg_payload_.disconnect_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.disconnect_request)
}
inline ::UsvLink::DisconnectRequest* MessagePacket::_internal_mutable_disconnect_request() {
  if (msg_payload_case() != kDisconnectRequest) {
    clear_msg_payload();
    set_has_disconnect_request();
    _impl_.msg_payload_.disconnect_request_ = CreateMaybeMessage<::UsvLink::DisconnectRequest>(GetArena());
  }
  return _impl_.msg_payload_.disconnect_request_;
}
inline ::UsvLink::DisconnectRequest* MessagePacket::mutable_disconnect_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::DisconnectRequest* _msg = _internal_mutable_disconnect_request();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.disconnect_request)
  return _msg;
}

// .UsvLink.DisconnectResponse disconnect_response = 13;
inline bool MessagePacket::has_disconnect_response() const {
  return msg_payload_case() == kDisconnectResponse;
}
inline bool MessagePacket::_internal_has_disconnect_response() const {
  return msg_payload_case() == kDisconnectResponse;
}
inline void MessagePacket::set_has_disconnect_response() {
  _impl_._oneof_case_[0] = kDisconnectResponse;
}
inline ::UsvLink::DisconnectResponse* MessagePacket::release_disconnect_response() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.disconnect_response)
  if (msg_payload_case() == kDisconnectResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.disconnect_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.disconnect_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::DisconnectResponse& MessagePacket::_internal_disconnect_response() const {
  return msg_payload_case() == kDisconnectResponse ? *_impl_.msg_payload_.disconnect_response_ : reinterpret_cast<::UsvLink::DisconnectResponse&>(::UsvLink::_DisconnectResponse_default_instance_);
}
inline const ::UsvLink::DisconnectResponse& MessagePacket::disconnect_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.disconnect_response)
  return _internal_disconnect_response();
}
inline ::UsvLink::DisconnectResponse* MessagePacket::unsafe_arena_release_disconnect_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.disconnect_response)
  if (msg_payload_case() == kDisconnectResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.disconnect_response_;
    _impl_.msg_payload_.disconnect_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_disconnect_response(::UsvLink::DisconnectResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_disconnect_response();
    _impl_.msg_payload_.disconnect_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.disconnect_response)
}
inline ::UsvLink::DisconnectResponse* MessagePacket::_internal_mutable_disconnect_response() {
  if (msg_payload_case() != kDisconnectResponse) {
    clear_msg_payload();
    set_has_disconnect_response();
    _impl_.msg_payload_.disconnect_response_ = CreateMaybeMessage<::UsvLink::DisconnectResponse>(GetArena());
  }
  return _impl_.msg_payload_.disconnect_response_;
}
inline ::UsvLink::DisconnectResponse* MessagePacket::mutable_disconnect_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::DisconnectResponse* _msg = _internal_mutable_disconnect_response();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.disconnect_response)
  return _msg;
}

// .UsvLink.ParamItem param_item = 14;
inline bool MessagePacket::has_param_item() const {
  return msg_payload_case() == kParamItem;
}
inline bool MessagePacket::_internal_has_param_item() const {
  return msg_payload_case() == kParamItem;
}
inline void MessagePacket::set_has_param_item() {
  _impl_._oneof_case_[0] = kParamItem;
}
inline ::UsvLink::ParamItem* MessagePacket::release_param_item() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.param_item)
  if (msg_payload_case() == kParamItem) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.param_item_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.param_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::ParamItem& MessagePacket::_internal_param_item() const {
  return msg_payload_case() == kParamItem ? *_impl_.msg_payload_.param_item_ : reinterpret_cast<::UsvLink::ParamItem&>(::UsvLink::_ParamItem_default_instance_);
}
inline const ::UsvLink::ParamItem& MessagePacket::param_item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.param_item)
  return _internal_param_item();
}
inline ::UsvLink::ParamItem* MessagePacket::unsafe_arena_release_param_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.param_item)
  if (msg_payload_case() == kParamItem) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.param_item_;
    _impl_.msg_payload_.param_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_param_item(::UsvLink::ParamItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_param_item();
    _impl_.msg_payload_.param_item_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.param_item)
}
inline ::UsvLink::ParamItem* MessagePacket::_internal_mutable_param_item() {
  if (msg_payload_case() != kParamItem) {
    clear_msg_payload();
    set_has_param_item();
    _impl_.msg_payload_.param_item_ = CreateMaybeMessage<::UsvLink::ParamItem>(GetArena());
  }
  return _impl_.msg_payload_.param_item_;
}
inline ::UsvLink::ParamItem* MessagePacket::mutable_param_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::ParamItem* _msg = _internal_mutable_param_item();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.param_item)
  return _msg;
}

// .UsvLink.ParamReadRequest param_read_request = 15;
inline bool MessagePacket::has_param_read_request() const {
  return msg_payload_case() == kParamReadRequest;
}
inline bool MessagePacket::_internal_has_param_read_request() const {
  return msg_payload_case() == kParamReadRequest;
}
inline void MessagePacket::set_has_param_read_request() {
  _impl_._oneof_case_[0] = kParamReadRequest;
}
inline ::UsvLink::ParamReadRequest* MessagePacket::release_param_read_request() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.param_read_request)
  if (msg_payload_case() == kParamReadRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.param_read_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.param_read_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::ParamReadRequest& MessagePacket::_internal_param_read_request() const {
  return msg_payload_case() == kParamReadRequest ? *_impl_.msg_payload_.param_read_request_ : reinterpret_cast<::UsvLink::ParamReadRequest&>(::UsvLink::_ParamReadRequest_default_instance_);
}
inline const ::UsvLink::ParamReadRequest& MessagePacket::param_read_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.param_read_request)
  return _internal_param_read_request();
}
inline ::UsvLink::ParamReadRequest* MessagePacket::unsafe_arena_release_param_read_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.param_read_request)
  if (msg_payload_case() == kParamReadRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.param_read_request_;
    _impl_.msg_payload_.param_read_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_param_read_request(::UsvLink::ParamReadRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_param_read_request();
    _impl_.msg_payload_.param_read_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.param_read_request)
}
inline ::UsvLink::ParamReadRequest* MessagePacket::_internal_mutable_param_read_request() {
  if (msg_payload_case() != kParamReadRequest) {
    clear_msg_payload();
    set_has_param_read_request();
    _impl_.msg_payload_.param_read_request_ = CreateMaybeMessage<::UsvLink::ParamReadRequest>(GetArena());
  }
  return _impl_.msg_payload_.param_read_request_;
}
inline ::UsvLink::ParamReadRequest* MessagePacket::mutable_param_read_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::ParamReadRequest* _msg = _internal_mutable_param_read_request();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.param_read_request)
  return _msg;
}

// .UsvLink.ParamReadResponse param_read_response = 16;
inline bool MessagePacket::has_param_read_response() const {
  return msg_payload_case() == kParamReadResponse;
}
inline bool MessagePacket::_internal_has_param_read_response() const {
  return msg_payload_case() == kParamReadResponse;
}
inline void MessagePacket::set_has_param_read_response() {
  _impl_._oneof_case_[0] = kParamReadResponse;
}
inline ::UsvLink::ParamReadResponse* MessagePacket::release_param_read_response() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.param_read_response)
  if (msg_payload_case() == kParamReadResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.param_read_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.param_read_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::ParamReadResponse& MessagePacket::_internal_param_read_response() const {
  return msg_payload_case() == kParamReadResponse ? *_impl_.msg_payload_.param_read_response_ : reinterpret_cast<::UsvLink::ParamReadResponse&>(::UsvLink::_ParamReadResponse_default_instance_);
}
inline const ::UsvLink::ParamReadResponse& MessagePacket::param_read_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.param_read_response)
  return _internal_param_read_response();
}
inline ::UsvLink::ParamReadResponse* MessagePacket::unsafe_arena_release_param_read_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.param_read_response)
  if (msg_payload_case() == kParamReadResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.param_read_response_;
    _impl_.msg_payload_.param_read_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_param_read_response(::UsvLink::ParamReadResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_param_read_response();
    _impl_.msg_payload_.param_read_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.param_read_response)
}
inline ::UsvLink::ParamReadResponse* MessagePacket::_internal_mutable_param_read_response() {
  if (msg_payload_case() != kParamReadResponse) {
    clear_msg_payload();
    set_has_param_read_response();
    _impl_.msg_payload_.param_read_response_ = CreateMaybeMessage<::UsvLink::ParamReadResponse>(GetArena());
  }
  return _impl_.msg_payload_.param_read_response_;
}
inline ::UsvLink::ParamReadResponse* MessagePacket::mutable_param_read_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::ParamReadResponse* _msg = _internal_mutable_param_read_response();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.param_read_response)
  return _msg;
}

// .UsvLink.ParamWriteRequest param_write_request = 17;
inline bool MessagePacket::has_param_write_request() const {
  return msg_payload_case() == kParamWriteRequest;
}
inline bool MessagePacket::_internal_has_param_write_request() const {
  return msg_payload_case() == kParamWriteRequest;
}
inline void MessagePacket::set_has_param_write_request() {
  _impl_._oneof_case_[0] = kParamWriteRequest;
}
inline ::UsvLink::ParamWriteRequest* MessagePacket::release_param_write_request() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.param_write_request)
  if (msg_payload_case() == kParamWriteRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.param_write_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.param_write_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::ParamWriteRequest& MessagePacket::_internal_param_write_request() const {
  return msg_payload_case() == kParamWriteRequest ? *_impl_.msg_payload_.param_write_request_ : reinterpret_cast<::UsvLink::ParamWriteRequest&>(::UsvLink::_ParamWriteRequest_default_instance_);
}
inline const ::UsvLink::ParamWriteRequest& MessagePacket::param_write_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.param_write_request)
  return _internal_param_write_request();
}
inline ::UsvLink::ParamWriteRequest* MessagePacket::unsafe_arena_release_param_write_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.param_write_request)
  if (msg_payload_case() == kParamWriteRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.param_write_request_;
    _impl_.msg_payload_.param_write_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_param_write_request(::UsvLink::ParamWriteRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_param_write_request();
    _impl_.msg_payload_.param_write_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.param_write_request)
}
inline ::UsvLink::ParamWriteRequest* MessagePacket::_internal_mutable_param_write_request() {
  if (msg_payload_case() != kParamWriteRequest) {
    clear_msg_payload();
    set_has_param_write_request();
    _impl_.msg_payload_.param_write_request_ = CreateMaybeMessage<::UsvLink::ParamWriteRequest>(GetArena());
  }
  return _impl_.msg_payload_.param_write_request_;
}
inline ::UsvLink::ParamWriteRequest* MessagePacket::mutable_param_write_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::ParamWriteRequest* _msg = _internal_mutable_param_write_request();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.param_write_request)
  return _msg;
}

// .UsvLink.ParamWriteResponse param_write_response = 18;
inline bool MessagePacket::has_param_write_response() const {
  return msg_payload_case() == kParamWriteResponse;
}
inline bool MessagePacket::_internal_has_param_write_response() const {
  return msg_payload_case() == kParamWriteResponse;
}
inline void MessagePacket::set_has_param_write_response() {
  _impl_._oneof_case_[0] = kParamWriteResponse;
}
inline ::UsvLink::ParamWriteResponse* MessagePacket::release_param_write_response() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.param_write_response)
  if (msg_payload_case() == kParamWriteResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.param_write_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.param_write_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::ParamWriteResponse& MessagePacket::_internal_param_write_response() const {
  return msg_payload_case() == kParamWriteResponse ? *_impl_.msg_payload_.param_write_response_ : reinterpret_cast<::UsvLink::ParamWriteResponse&>(::UsvLink::_ParamWriteResponse_default_instance_);
}
inline const ::UsvLink::ParamWriteResponse& MessagePacket::param_write_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.param_write_response)
  return _internal_param_write_response();
}
inline ::UsvLink::ParamWriteResponse* MessagePacket::unsafe_arena_release_param_write_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.param_write_response)
  if (msg_payload_case() == kParamWriteResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.param_write_response_;
    _impl_.msg_payload_.param_write_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_param_write_response(::UsvLink::ParamWriteResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_param_write_response();
    _impl_.msg_payload_.param_write_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.param_write_response)
}
inline ::UsvLink::ParamWriteResponse* MessagePacket::_internal_mutable_param_write_response() {
  if (msg_payload_case() != kParamWriteResponse) {
    clear_msg_payload();
    set_has_param_write_response();
    _impl_.msg_payload_.param_write_response_ = CreateMaybeMessage<::UsvLink::ParamWriteResponse>(GetArena());
  }
  return _impl_.msg_payload_.param_write_response_;
}
inline ::UsvLink::ParamWriteResponse* MessagePacket::mutable_param_write_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::ParamWriteResponse* _msg = _internal_mutable_param_write_response();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.param_write_response)
  return _msg;
}

// .UsvLink.MissionItem mission_item = 19;
inline bool MessagePacket::has_mission_item() const {
  return msg_payload_case() == kMissionItem;
}
inline bool MessagePacket::_internal_has_mission_item() const {
  return msg_payload_case() == kMissionItem;
}
inline void MessagePacket::set_has_mission_item() {
  _impl_._oneof_case_[0] = kMissionItem;
}
inline ::UsvLink::MissionItem* MessagePacket::release_mission_item() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.mission_item)
  if (msg_payload_case() == kMissionItem) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_item_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.mission_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::MissionItem& MessagePacket::_internal_mission_item() const {
  return msg_payload_case() == kMissionItem ? *_impl_.msg_payload_.mission_item_ : reinterpret_cast<::UsvLink::MissionItem&>(::UsvLink::_MissionItem_default_instance_);
}
inline const ::UsvLink::MissionItem& MessagePacket::mission_item() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.mission_item)
  return _internal_mission_item();
}
inline ::UsvLink::MissionItem* MessagePacket::unsafe_arena_release_mission_item() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.mission_item)
  if (msg_payload_case() == kMissionItem) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_item_;
    _impl_.msg_payload_.mission_item_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_mission_item(::UsvLink::MissionItem* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_mission_item();
    _impl_.msg_payload_.mission_item_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.mission_item)
}
inline ::UsvLink::MissionItem* MessagePacket::_internal_mutable_mission_item() {
  if (msg_payload_case() != kMissionItem) {
    clear_msg_payload();
    set_has_mission_item();
    _impl_.msg_payload_.mission_item_ = CreateMaybeMessage<::UsvLink::MissionItem>(GetArena());
  }
  return _impl_.msg_payload_.mission_item_;
}
inline ::UsvLink::MissionItem* MessagePacket::mutable_mission_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::MissionItem* _msg = _internal_mutable_mission_item();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.mission_item)
  return _msg;
}

// .UsvLink.MissionDownloadRequest mission_download_request = 20;
inline bool MessagePacket::has_mission_download_request() const {
  return msg_payload_case() == kMissionDownloadRequest;
}
inline bool MessagePacket::_internal_has_mission_download_request() const {
  return msg_payload_case() == kMissionDownloadRequest;
}
inline void MessagePacket::set_has_mission_download_request() {
  _impl_._oneof_case_[0] = kMissionDownloadRequest;
}
inline ::UsvLink::MissionDownloadRequest* MessagePacket::release_mission_download_request() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.mission_download_request)
  if (msg_payload_case() == kMissionDownloadRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_download_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.mission_download_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::MissionDownloadRequest& MessagePacket::_internal_mission_download_request() const {
  return msg_payload_case() == kMissionDownloadRequest ? *_impl_.msg_payload_.mission_download_request_ : reinterpret_cast<::UsvLink::MissionDownloadRequest&>(::UsvLink::_MissionDownloadRequest_default_instance_);
}
inline const ::UsvLink::MissionDownloadRequest& MessagePacket::mission_download_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.mission_download_request)
  return _internal_mission_download_request();
}
inline ::UsvLink::MissionDownloadRequest* MessagePacket::unsafe_arena_release_mission_download_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.mission_download_request)
  if (msg_payload_case() == kMissionDownloadRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_download_request_;
    _impl_.msg_payload_.mission_download_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_mission_download_request(::UsvLink::MissionDownloadRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_mission_download_request();
    _impl_.msg_payload_.mission_download_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.mission_download_request)
}
inline ::UsvLink::MissionDownloadRequest* MessagePacket::_internal_mutable_mission_download_request() {
  if (msg_payload_case() != kMissionDownloadRequest) {
    clear_msg_payload();
    set_has_mission_download_request();
    _impl_.msg_payload_.mission_download_request_ = CreateMaybeMessage<::UsvLink::MissionDownloadRequest>(GetArena());
  }
  return _impl_.msg_payload_.mission_download_request_;
}
inline ::UsvLink::MissionDownloadRequest* MessagePacket::mutable_mission_download_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::MissionDownloadRequest* _msg = _internal_mutable_mission_download_request();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.mission_download_request)
  return _msg;
}

// .UsvLink.MissionDownloadResponse mission_download_response = 21;
inline bool MessagePacket::has_mission_download_response() const {
  return msg_payload_case() == kMissionDownloadResponse;
}
inline bool MessagePacket::_internal_has_mission_download_response() const {
  return msg_payload_case() == kMissionDownloadResponse;
}
inline void MessagePacket::set_has_mission_download_response() {
  _impl_._oneof_case_[0] = kMissionDownloadResponse;
}
inline ::UsvLink::MissionDownloadResponse* MessagePacket::release_mission_download_response() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.mission_download_response)
  if (msg_payload_case() == kMissionDownloadResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_download_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.mission_download_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::MissionDownloadResponse& MessagePacket::_internal_mission_download_response() const {
  return msg_payload_case() == kMissionDownloadResponse ? *_impl_.msg_payload_.mission_download_response_ : reinterpret_cast<::UsvLink::MissionDownloadResponse&>(::UsvLink::_MissionDownloadResponse_default_instance_);
}
inline const ::UsvLink::MissionDownloadResponse& MessagePacket::mission_download_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.mission_download_response)
  return _internal_mission_download_response();
}
inline ::UsvLink::MissionDownloadResponse* MessagePacket::unsafe_arena_release_mission_download_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.mission_download_response)
  if (msg_payload_case() == kMissionDownloadResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_download_response_;
    _impl_.msg_payload_.mission_download_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_mission_download_response(::UsvLink::MissionDownloadResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_mission_download_response();
    _impl_.msg_payload_.mission_download_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.mission_download_response)
}
inline ::UsvLink::MissionDownloadResponse* MessagePacket::_internal_mutable_mission_download_response() {
  if (msg_payload_case() != kMissionDownloadResponse) {
    clear_msg_payload();
    set_has_mission_download_response();
    _impl_.msg_payload_.mission_download_response_ = CreateMaybeMessage<::UsvLink::MissionDownloadResponse>(GetArena());
  }
  return _impl_.msg_payload_.mission_download_response_;
}
inline ::UsvLink::MissionDownloadResponse* MessagePacket::mutable_mission_download_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::MissionDownloadResponse* _msg = _internal_mutable_mission_download_response();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.mission_download_response)
  return _msg;
}

// .UsvLink.MissionUploadRequest mission_upload_request = 22;
inline bool MessagePacket::has_mission_upload_request() const {
  return msg_payload_case() == kMissionUploadRequest;
}
inline bool MessagePacket::_internal_has_mission_upload_request() const {
  return msg_payload_case() == kMissionUploadRequest;
}
inline void MessagePacket::set_has_mission_upload_request() {
  _impl_._oneof_case_[0] = kMissionUploadRequest;
}
inline ::UsvLink::MissionUploadRequest* MessagePacket::release_mission_upload_request() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.mission_upload_request)
  if (msg_payload_case() == kMissionUploadRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_upload_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.mission_upload_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::MissionUploadRequest& MessagePacket::_internal_mission_upload_request() const {
  return msg_payload_case() == kMissionUploadRequest ? *_impl_.msg_payload_.mission_upload_request_ : reinterpret_cast<::UsvLink::MissionUploadRequest&>(::UsvLink::_MissionUploadRequest_default_instance_);
}
inline const ::UsvLink::MissionUploadRequest& MessagePacket::mission_upload_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.mission_upload_request)
  return _internal_mission_upload_request();
}
inline ::UsvLink::MissionUploadRequest* MessagePacket::unsafe_arena_release_mission_upload_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.mission_upload_request)
  if (msg_payload_case() == kMissionUploadRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_upload_request_;
    _impl_.msg_payload_.mission_upload_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_mission_upload_request(::UsvLink::MissionUploadRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_mission_upload_request();
    _impl_.msg_payload_.mission_upload_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.mission_upload_request)
}
inline ::UsvLink::MissionUploadRequest* MessagePacket::_internal_mutable_mission_upload_request() {
  if (msg_payload_case() != kMissionUploadRequest) {
    clear_msg_payload();
    set_has_mission_upload_request();
    _impl_.msg_payload_.mission_upload_request_ = CreateMaybeMessage<::UsvLink::MissionUploadRequest>(GetArena());
  }
  return _impl_.msg_payload_.mission_upload_request_;
}
inline ::UsvLink::MissionUploadRequest* MessagePacket::mutable_mission_upload_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::MissionUploadRequest* _msg = _internal_mutable_mission_upload_request();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.mission_upload_request)
  return _msg;
}

// .UsvLink.MissionUploadResponse mission_upload_response = 23;
inline bool MessagePacket::has_mission_upload_response() const {
  return msg_payload_case() == kMissionUploadResponse;
}
inline bool MessagePacket::_internal_has_mission_upload_response() const {
  return msg_payload_case() == kMissionUploadResponse;
}
inline void MessagePacket::set_has_mission_upload_response() {
  _impl_._oneof_case_[0] = kMissionUploadResponse;
}
inline ::UsvLink::MissionUploadResponse* MessagePacket::release_mission_upload_response() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.mission_upload_response)
  if (msg_payload_case() == kMissionUploadResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_upload_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.mission_upload_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::MissionUploadResponse& MessagePacket::_internal_mission_upload_response() const {
  return msg_payload_case() == kMissionUploadResponse ? *_impl_.msg_payload_.mission_upload_response_ : reinterpret_cast<::UsvLink::MissionUploadResponse&>(::UsvLink::_MissionUploadResponse_default_instance_);
}
inline const ::UsvLink::MissionUploadResponse& MessagePacket::mission_upload_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.mission_upload_response)
  return _internal_mission_upload_response();
}
inline ::UsvLink::MissionUploadResponse* MessagePacket::unsafe_arena_release_mission_upload_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.mission_upload_response)
  if (msg_payload_case() == kMissionUploadResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_upload_response_;
    _impl_.msg_payload_.mission_upload_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_mission_upload_response(::UsvLink::MissionUploadResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_mission_upload_response();
    _impl_.msg_payload_.mission_upload_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.mission_upload_response)
}
inline ::UsvLink::MissionUploadResponse* MessagePacket::_internal_mutable_mission_upload_response() {
  if (msg_payload_case() != kMissionUploadResponse) {
    clear_msg_payload();
    set_has_mission_upload_response();
    _impl_.msg_payload_.mission_upload_response_ = CreateMaybeMessage<::UsvLink::MissionUploadResponse>(GetArena());
  }
  return _impl_.msg_payload_.mission_upload_response_;
}
inline ::UsvLink::MissionUploadResponse* MessagePacket::mutable_mission_upload_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::MissionUploadResponse* _msg = _internal_mutable_mission_upload_response();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.mission_upload_response)
  return _msg;
}

// .UsvLink.MissionCurrent mission_current = 24;
inline bool MessagePacket::has_mission_current() const {
  return msg_payload_case() == kMissionCurrent;
}
inline bool MessagePacket::_internal_has_mission_current() const {
  return msg_payload_case() == kMissionCurrent;
}
inline void MessagePacket::set_has_mission_current() {
  _impl_._oneof_case_[0] = kMissionCurrent;
}
inline ::UsvLink::MissionCurrent* MessagePacket::release_mission_current() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.mission_current)
  if (msg_payload_case() == kMissionCurrent) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_current_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.mission_current_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::MissionCurrent& MessagePacket::_internal_mission_current() const {
  return msg_payload_case() == kMissionCurrent ? *_impl_.msg_payload_.mission_current_ : reinterpret_cast<::UsvLink::MissionCurrent&>(::UsvLink::_MissionCurrent_default_instance_);
}
inline const ::UsvLink::MissionCurrent& MessagePacket::mission_current() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.mission_current)
  return _internal_mission_current();
}
inline ::UsvLink::MissionCurrent* MessagePacket::unsafe_arena_release_mission_current() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.mission_current)
  if (msg_payload_case() == kMissionCurrent) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_current_;
    _impl_.msg_payload_.mission_current_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_mission_current(::UsvLink::MissionCurrent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_mission_current();
    _impl_.msg_payload_.mission_current_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.mission_current)
}
inline ::UsvLink::MissionCurrent* MessagePacket::_internal_mutable_mission_current() {
  if (msg_payload_case() != kMissionCurrent) {
    clear_msg_payload();
    set_has_mission_current();
    _impl_.msg_payload_.mission_current_ = CreateMaybeMessage<::UsvLink::MissionCurrent>(GetArena());
  }
  return _impl_.msg_payload_.mission_current_;
}
inline ::UsvLink::MissionCurrent* MessagePacket::mutable_mission_current() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::MissionCurrent* _msg = _internal_mutable_mission_current();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.mission_current)
  return _msg;
}

// .UsvLink.MissionSetCurrent mission_set_current = 25;
inline bool MessagePacket::has_mission_set_current() const {
  return msg_payload_case() == kMissionSetCurrent;
}
inline bool MessagePacket::_internal_has_mission_set_current() const {
  return msg_payload_case() == kMissionSetCurrent;
}
inline void MessagePacket::set_has_mission_set_current() {
  _impl_._oneof_case_[0] = kMissionSetCurrent;
}
inline ::UsvLink::MissionSetCurrent* MessagePacket::release_mission_set_current() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.mission_set_current)
  if (msg_payload_case() == kMissionSetCurrent) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_set_current_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.mission_set_current_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::MissionSetCurrent& MessagePacket::_internal_mission_set_current() const {
  return msg_payload_case() == kMissionSetCurrent ? *_impl_.msg_payload_.mission_set_current_ : reinterpret_cast<::UsvLink::MissionSetCurrent&>(::UsvLink::_MissionSetCurrent_default_instance_);
}
inline const ::UsvLink::MissionSetCurrent& MessagePacket::mission_set_current() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.mission_set_current)
  return _internal_mission_set_current();
}
inline ::UsvLink::MissionSetCurrent* MessagePacket::unsafe_arena_release_mission_set_current() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.mission_set_current)
  if (msg_payload_case() == kMissionSetCurrent) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_set_current_;
    _impl_.msg_payload_.mission_set_current_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_mission_set_current(::UsvLink::MissionSetCurrent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_mission_set_current();
    _impl_.msg_payload_.mission_set_current_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.mission_set_current)
}
inline ::UsvLink::MissionSetCurrent* MessagePacket::_internal_mutable_mission_set_current() {
  if (msg_payload_case() != kMissionSetCurrent) {
    clear_msg_payload();
    set_has_mission_set_current();
    _impl_.msg_payload_.mission_set_current_ = CreateMaybeMessage<::UsvLink::MissionSetCurrent>(GetArena());
  }
  return _impl_.msg_payload_.mission_set_current_;
}
inline ::UsvLink::MissionSetCurrent* MessagePacket::mutable_mission_set_current() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::MissionSetCurrent* _msg = _internal_mutable_mission_set_current();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.mission_set_current)
  return _msg;
}

// .UsvLink.MissionClearRequest mission_clear_request = 26;
inline bool MessagePacket::has_mission_clear_request() const {
  return msg_payload_case() == kMissionClearRequest;
}
inline bool MessagePacket::_internal_has_mission_clear_request() const {
  return msg_payload_case() == kMissionClearRequest;
}
inline void MessagePacket::set_has_mission_clear_request() {
  _impl_._oneof_case_[0] = kMissionClearRequest;
}
inline ::UsvLink::MissionClearRequest* MessagePacket::release_mission_clear_request() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.mission_clear_request)
  if (msg_payload_case() == kMissionClearRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_clear_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.mission_clear_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::MissionClearRequest& MessagePacket::_internal_mission_clear_request() const {
  return msg_payload_case() == kMissionClearRequest ? *_impl_.msg_payload_.mission_clear_request_ : reinterpret_cast<::UsvLink::MissionClearRequest&>(::UsvLink::_MissionClearRequest_default_instance_);
}
inline const ::UsvLink::MissionClearRequest& MessagePacket::mission_clear_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.mission_clear_request)
  return _internal_mission_clear_request();
}
inline ::UsvLink::MissionClearRequest* MessagePacket::unsafe_arena_release_mission_clear_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.mission_clear_request)
  if (msg_payload_case() == kMissionClearRequest) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_clear_request_;
    _impl_.msg_payload_.mission_clear_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_mission_clear_request(::UsvLink::MissionClearRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_mission_clear_request();
    _impl_.msg_payload_.mission_clear_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.mission_clear_request)
}
inline ::UsvLink::MissionClearRequest* MessagePacket::_internal_mutable_mission_clear_request() {
  if (msg_payload_case() != kMissionClearRequest) {
    clear_msg_payload();
    set_has_mission_clear_request();
    _impl_.msg_payload_.mission_clear_request_ = CreateMaybeMessage<::UsvLink::MissionClearRequest>(GetArena());
  }
  return _impl_.msg_payload_.mission_clear_request_;
}
inline ::UsvLink::MissionClearRequest* MessagePacket::mutable_mission_clear_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::MissionClearRequest* _msg = _internal_mutable_mission_clear_request();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.mission_clear_request)
  return _msg;
}

// .UsvLink.MissionClearResponse mission_clear_response = 27;
inline bool MessagePacket::has_mission_clear_response() const {
  return msg_payload_case() == kMissionClearResponse;
}
inline bool MessagePacket::_internal_has_mission_clear_response() const {
  return msg_payload_case() == kMissionClearResponse;
}
inline void MessagePacket::set_has_mission_clear_response() {
  _impl_._oneof_case_[0] = kMissionClearResponse;
}
inline ::UsvLink::MissionClearResponse* MessagePacket::release_mission_clear_response() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.mission_clear_response)
  if (msg_payload_case() == kMissionClearResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_clear_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.mission_clear_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::MissionClearResponse& MessagePacket::_internal_mission_clear_response() const {
  return msg_payload_case() == kMissionClearResponse ? *_impl_.msg_payload_.mission_clear_response_ : reinterpret_cast<::UsvLink::MissionClearResponse&>(::UsvLink::_MissionClearResponse_default_instance_);
}
inline const ::UsvLink::MissionClearResponse& MessagePacket::mission_clear_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.mission_clear_response)
  return _internal_mission_clear_response();
}
inline ::UsvLink::MissionClearResponse* MessagePacket::unsafe_arena_release_mission_clear_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.mission_clear_response)
  if (msg_payload_case() == kMissionClearResponse) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.mission_clear_response_;
    _impl_.msg_payload_.mission_clear_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_mission_clear_response(::UsvLink::MissionClearResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_mission_clear_response();
    _impl_.msg_payload_.mission_clear_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.mission_clear_response)
}
inline ::UsvLink::MissionClearResponse* MessagePacket::_internal_mutable_mission_clear_response() {
  if (msg_payload_case() != kMissionClearResponse) {
    clear_msg_payload();
    set_has_mission_clear_response();
    _impl_.msg_payload_.mission_clear_response_ = CreateMaybeMessage<::UsvLink::MissionClearResponse>(GetArena());
  }
  return _impl_.msg_payload_.mission_clear_response_;
}
inline ::UsvLink::MissionClearResponse* MessagePacket::mutable_mission_clear_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::MissionClearResponse* _msg = _internal_mutable_mission_clear_response();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.mission_clear_response)
  return _msg;
}

// .UsvLink.BatteryStatus battery_status = 28;
inline bool MessagePacket::has_battery_status() const {
  return msg_payload_case() == kBatteryStatus;
}
inline bool MessagePacket::_internal_has_battery_status() const {
  return msg_payload_case() == kBatteryStatus;
}
inline void MessagePacket::set_has_battery_status() {
  _impl_._oneof_case_[0] = kBatteryStatus;
}
inline ::UsvLink::BatteryStatus* MessagePacket::release_battery_status() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.battery_status)
  if (msg_payload_case() == kBatteryStatus) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.battery_status_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.battery_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::BatteryStatus& MessagePacket::_internal_battery_status() const {
  return msg_payload_case() == kBatteryStatus ? *_impl_.msg_payload_.battery_status_ : reinterpret_cast<::UsvLink::BatteryStatus&>(::UsvLink::_BatteryStatus_default_instance_);
}
inline const ::UsvLink::BatteryStatus& MessagePacket::battery_status() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.battery_status)
  return _internal_battery_status();
}
inline ::UsvLink::BatteryStatus* MessagePacket::unsafe_arena_release_battery_status() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.battery_status)
  if (msg_payload_case() == kBatteryStatus) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.battery_status_;
    _impl_.msg_payload_.battery_status_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_battery_status(::UsvLink::BatteryStatus* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_battery_status();
    _impl_.msg_payload_.battery_status_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.battery_status)
}
inline ::UsvLink::BatteryStatus* MessagePacket::_internal_mutable_battery_status() {
  if (msg_payload_case() != kBatteryStatus) {
    clear_msg_payload();
    set_has_battery_status();
    _impl_.msg_payload_.battery_status_ = CreateMaybeMessage<::UsvLink::BatteryStatus>(GetArena());
  }
  return _impl_.msg_payload_.battery_status_;
}
inline ::UsvLink::BatteryStatus* MessagePacket::mutable_battery_status() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::BatteryStatus* _msg = _internal_mutable_battery_status();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.battery_status)
  return _msg;
}

// .UsvLink.Command command = 29;
inline bool MessagePacket::has_command() const {
  return msg_payload_case() == kCommand;
}
inline bool MessagePacket::_internal_has_command() const {
  return msg_payload_case() == kCommand;
}
inline void MessagePacket::set_has_command() {
  _impl_._oneof_case_[0] = kCommand;
}
inline ::UsvLink::Command* MessagePacket::release_command() {
  // @@protoc_insertion_point(field_release:UsvLink.MessagePacket.command)
  if (msg_payload_case() == kCommand) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.command_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_payload_.command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UsvLink::Command& MessagePacket::_internal_command() const {
  return msg_payload_case() == kCommand ? *_impl_.msg_payload_.command_ : reinterpret_cast<::UsvLink::Command&>(::UsvLink::_Command_default_instance_);
}
inline const ::UsvLink::Command& MessagePacket::command() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:UsvLink.MessagePacket.command)
  return _internal_command();
}
inline ::UsvLink::Command* MessagePacket::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UsvLink.MessagePacket.command)
  if (msg_payload_case() == kCommand) {
    clear_has_msg_payload();
    auto* temp = _impl_.msg_payload_.command_;
    _impl_.msg_payload_.command_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessagePacket::unsafe_arena_set_allocated_command(::UsvLink::Command* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg_payload();
  if (value) {
    set_has_command();
    _impl_.msg_payload_.command_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UsvLink.MessagePacket.command)
}
inline ::UsvLink::Command* MessagePacket::_internal_mutable_command() {
  if (msg_payload_case() != kCommand) {
    clear_msg_payload();
    set_has_command();
    _impl_.msg_payload_.command_ = CreateMaybeMessage<::UsvLink::Command>(GetArena());
  }
  return _impl_.msg_payload_.command_;
}
inline ::UsvLink::Command* MessagePacket::mutable_command() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::UsvLink::Command* _msg = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:UsvLink.MessagePacket.command)
  return _msg;
}

inline bool MessagePacket::has_msg_payload() const {
  return msg_payload_case() != MSG_PAYLOAD_NOT_SET;
}
inline void MessagePacket::clear_has_msg_payload() {
  _impl_._oneof_case_[0] = MSG_PAYLOAD_NOT_SET;
}
inline MessagePacket::MsgPayloadCase MessagePacket::msg_payload_case() const {
  return MessagePacket::MsgPayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace UsvLink


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_link_5fprotocol_2eproto_2epb_2eh
