// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg_enum.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_5fenum_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_msg_5fenum_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_msg_5fenum_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_5fenum_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_msg_5fenum_2eproto;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace UsvLink {
enum MsgSrc : int {
  MSG_SRC_USV = 0,
  MSG_SRC_GCS = 1,
  MSG_SRC_SERVER = 2,
  MsgSrc_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MsgSrc_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MsgSrc_IsValid(int value);
extern const uint32_t MsgSrc_internal_data_[];
constexpr MsgSrc MsgSrc_MIN = static_cast<MsgSrc>(0);
constexpr MsgSrc MsgSrc_MAX = static_cast<MsgSrc>(2);
constexpr int MsgSrc_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
MsgSrc_descriptor();
template <typename T>
const std::string& MsgSrc_Name(T value) {
  static_assert(std::is_same<T, MsgSrc>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgSrc_Name().");
  return MsgSrc_Name(static_cast<MsgSrc>(value));
}
template <>
inline const std::string& MsgSrc_Name(MsgSrc value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MsgSrc_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool MsgSrc_Parse(absl::string_view name, MsgSrc* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgSrc>(
      MsgSrc_descriptor(), name, value);
}
enum MsgLink : int {
  MSG_LINK_MQTT = 0,
  MSG_LINK_SERIAL_PORT = 1,
  MsgLink_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MsgLink_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MsgLink_IsValid(int value);
extern const uint32_t MsgLink_internal_data_[];
constexpr MsgLink MsgLink_MIN = static_cast<MsgLink>(0);
constexpr MsgLink MsgLink_MAX = static_cast<MsgLink>(1);
constexpr int MsgLink_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
MsgLink_descriptor();
template <typename T>
const std::string& MsgLink_Name(T value) {
  static_assert(std::is_same<T, MsgLink>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgLink_Name().");
  return MsgLink_Name(static_cast<MsgLink>(value));
}
template <>
inline const std::string& MsgLink_Name(MsgLink value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MsgLink_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool MsgLink_Parse(absl::string_view name, MsgLink* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgLink>(
      MsgLink_descriptor(), name, value);
}
enum MsgId : int {
  MSG_ID_HEARTBEAT = 0,
  MSG_ID_CONNECT_REQUEST = 1,
  MSG_ID_CONNECT_RESPONSE = 2,
  MSG_ID_DISCONNECT_REQUEST = 3,
  MSG_ID_DISCONNECT_RESPONSE = 4,
  MSG_ID_PARAM_ITEM = 5,
  MSG_ID_PARAM_READ_REQUEST = 6,
  MSG_ID_PARAM_READ_RESPONSE = 7,
  MSG_ID_PARAM_WRITE_REQUEST = 8,
  MSG_ID_PARAM_WRITE_RESPONSE = 9,
  MSG_ID_MISSION_ITEM = 10,
  MSG_ID_MISSION_DOWNLOAD_REQUEST = 11,
  MSG_ID_MISSION_DOWNLOAD_RESPONSE = 12,
  MSG_ID_MISSION_UPLOAD_REQUEST = 13,
  MSG_ID_MISSION_UPLOAD_RESPONSE = 14,
  MSG_ID_MISSION_CURRENT = 15,
  MSG_ID_MISSION_SET_CURRENT = 16,
  MSG_ID_MISSION_CLEAR_REQUEST = 17,
  MSG_ID_MISSION_CLEAR_RESPONSE = 18,
  MSG_ID_BATTERY_STATUS = 19,
  MSG_ID_COMMAND = 20,
  MsgId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MsgId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MsgId_IsValid(int value);
extern const uint32_t MsgId_internal_data_[];
constexpr MsgId MsgId_MIN = static_cast<MsgId>(0);
constexpr MsgId MsgId_MAX = static_cast<MsgId>(20);
constexpr int MsgId_ARRAYSIZE = 20 + 1;
const ::google::protobuf::EnumDescriptor*
MsgId_descriptor();
template <typename T>
const std::string& MsgId_Name(T value) {
  static_assert(std::is_same<T, MsgId>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgId_Name().");
  return MsgId_Name(static_cast<MsgId>(value));
}
template <>
inline const std::string& MsgId_Name(MsgId value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MsgId_descriptor,
                                                 0, 20>(
      static_cast<int>(value));
}
inline bool MsgId_Parse(absl::string_view name, MsgId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgId>(
      MsgId_descriptor(), name, value);
}
enum CmdId : int {
  CMD_ID_NAV_WAYPOINT = 0,
  CMD_ID_DO_WEIGH_ANCHOR = 1,
  CMD_ID_DO_DROP_ANCHOR = 2,
  CmdId_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CmdId_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CmdId_IsValid(int value);
extern const uint32_t CmdId_internal_data_[];
constexpr CmdId CmdId_MIN = static_cast<CmdId>(0);
constexpr CmdId CmdId_MAX = static_cast<CmdId>(2);
constexpr int CmdId_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
CmdId_descriptor();
template <typename T>
const std::string& CmdId_Name(T value) {
  static_assert(std::is_same<T, CmdId>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CmdId_Name().");
  return CmdId_Name(static_cast<CmdId>(value));
}
template <>
inline const std::string& CmdId_Name(CmdId value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CmdId_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool CmdId_Parse(absl::string_view name, CmdId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CmdId>(
      CmdId_descriptor(), name, value);
}
enum Frame : int {
  FRAME_GLOBAL = 0,
  FRAME_LOCAL_NED = 1,
  FRAME_GLOBAL_RELATIVE_ALT = 2,
  FRAME_LOCAL_ENU = 3,
  FRAME_LOCAL_OFFSET_NED = 4,
  FRAME_GLOBAL_TERRAIN_ALT = 5,
  FRAME_BODY_FRD = 6,
  FRAME_LOCAL_FRD = 7,
  FRAME_LOCAL_FLU = 8,
  Frame_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Frame_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Frame_IsValid(int value);
extern const uint32_t Frame_internal_data_[];
constexpr Frame Frame_MIN = static_cast<Frame>(0);
constexpr Frame Frame_MAX = static_cast<Frame>(8);
constexpr int Frame_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
Frame_descriptor();
template <typename T>
const std::string& Frame_Name(T value) {
  static_assert(std::is_same<T, Frame>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Frame_Name().");
  return Frame_Name(static_cast<Frame>(value));
}
template <>
inline const std::string& Frame_Name(Frame value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Frame_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool Frame_Parse(absl::string_view name, Frame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Frame>(
      Frame_descriptor(), name, value);
}
enum MissionState : int {
  MISSION_STATE_UNKNOWN = 0,
  MISSION_STATE_NO_MISSION = 1,
  MISSION_STATE_NOT_STARTED = 2,
  MISSION_STATE_ACTIVE = 3,
  MISSION_STATE_PAUSED = 4,
  MISSION_STATE_COMPLETE = 5,
  MissionState_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MissionState_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MissionState_IsValid(int value);
extern const uint32_t MissionState_internal_data_[];
constexpr MissionState MissionState_MIN = static_cast<MissionState>(0);
constexpr MissionState MissionState_MAX = static_cast<MissionState>(5);
constexpr int MissionState_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
MissionState_descriptor();
template <typename T>
const std::string& MissionState_Name(T value) {
  static_assert(std::is_same<T, MissionState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MissionState_Name().");
  return MissionState_Name(static_cast<MissionState>(value));
}
template <>
inline const std::string& MissionState_Name(MissionState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MissionState_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool MissionState_Parse(absl::string_view name, MissionState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MissionState>(
      MissionState_descriptor(), name, value);
}

// ===================================================================



// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace UsvLink


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::UsvLink::MsgSrc> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::UsvLink::MsgSrc>() {
  return ::UsvLink::MsgSrc_descriptor();
}
template <>
struct is_proto_enum<::UsvLink::MsgLink> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::UsvLink::MsgLink>() {
  return ::UsvLink::MsgLink_descriptor();
}
template <>
struct is_proto_enum<::UsvLink::MsgId> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::UsvLink::MsgId>() {
  return ::UsvLink::MsgId_descriptor();
}
template <>
struct is_proto_enum<::UsvLink::CmdId> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::UsvLink::CmdId>() {
  return ::UsvLink::CmdId_descriptor();
}
template <>
struct is_proto_enum<::UsvLink::Frame> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::UsvLink::Frame>() {
  return ::UsvLink::Frame_descriptor();
}
template <>
struct is_proto_enum<::UsvLink::MissionState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::UsvLink::MissionState>() {
  return ::UsvLink::MissionState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_msg_5fenum_2eproto_2epb_2eh
